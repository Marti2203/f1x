# Manual #

f1x [ɛf-wʌn-ɛks] is a test-driven patch generation engine for C/C++ programs. It automatically finds and fixes software bugs by analyzing behaviour of passing and failing tests. f1x aims to be efficient, robust and easy-to-use.

## Characteristics ##

f1x is primarily designed to repair C programs (tested on real-world projects such as PHP, Python, etc.), but it also provides initial support for C++ (tested on small programs). f1x currently works on Linux-based systems (tested on Ubuntu 14.04 and Ubuntu 16.04).

### Search space ###

Search space is the set of syntactical changes that can be generated by a program repair system. The search space of f1x is defined by the following transformation schemas:

1. `expression`: modifying side-effect free expressions (conditions, RHS of assignments, return arguments);
2. `refinement`: appending `|| expr` and `&& expr` to conditions;
3. `assignment`: inserting assignment statements;
4. `guard`: inserting if-guards for break, continue, function calls;
5. `initialization`: inserting memory initialization;
6. `function`: replace a function call with another similar function call.

f1x expression synthesizer is bit-precise; it supports all builtin (C99) integer types and pointers.

### Test-equivalence analyses ###

f1x performs search by applying and testing candidate patches.
Since the search space of f1x includes a huge number of program changes, it is inefficient to test each change individually.
In order to address this, f1x implements several test-equivalence analyses that help to avoid redundant test executions:

1. `vteq`: value-based test-equivalence analysis (for side-effect free program expressions).
2. `dteq`: dependency-based test-equivalence analysis (for assignment synthesis).

### Prioritization ###

Search space prioritization can be thought of as a function that assigns lower cost to better patches. It is straightforward to implement prioritization strategies in f1x, since the search space is represented explicitly and applying prioritization is simply sorting an array. f1x currently supports the following prioritization strategies:

1. `syntax-diff`: minimize syntactic change (patches that are syntactically closer to the original program are assigned lower cost). The motivation behind this prioritization is that small changes are easier to understand and they are less likely to break existing functionality.

## Usage ##

**Warning!** f1x executes arbitrary modifications of your source code which may lead to undesirable side effects. Therefore, it is recommended to run f1x in an isolated environment. Apply f1x to a copy of your application, since it can corrupt the source code.
    
In order to repair a program, f1x requires a special build configuration and an interface to the testing framework.

### Project ###

The input to f1x is a project, which is simply a directory such that:

- all source files that may contain a bug are in the project root directory or its subdirectories;
- the program is build by executing a command from the project root directory;
- each test can be run by executing a command from the project root directory.

It order to let f1x transform and compile your application, you need to substitute C compiler in your build system with the `f1x-cc` tool. For instance, autotools-based projects require

- configuring using f1x compiler wrapper (e.g. `CC=f1x-cc CXX=f1x-cxx ./configure`)
- removing binaries before executing f1x (e.g. `make clean`)
- ensuring that the build command uses the compilers from `CC` and `CXX` environment variables (e.g. use `make` with the `-e` option)

f1x needs to be able to execute an arbitrary test to identify if this test passes or fails. To abstract over testing frameworks, f1x uses the following entities:

- A set of unique test identifiers (e.g. "test1", "test2", ...).
- A test driver executable that accepts a test identifier as the only argument, runs the corresponding test, and terminates with zero exit code if and only if the test passes. The test driver is executed from the project root directory.

When executing tests, f1x appends a path to its runtime library (libf1xrt.so) to the `LD_LIBRARY_PATH` environment variable. Therefore, the testing framework should not overwrite this variable.

In order to perfrom `dteq` analysis, f1x uses dynamic program instrumentation. To enable this, the testing framework has to execute the application binary using the command stored in `F1X_RUN` environment variable, if it is defined. For Bash test scripts, this can be achieved by simply placing `$F1X_RUN` in front of the program execution command:

    assert-equal () {
        diff -q <($F1X_RUN $1) <(echo -ne "$2") > /dev/null
    }

    case "$1" in
        test1)
            assert-equal "./program 1 2" '1\n'
            ;;
    esac

Note that `F1X_RUN` is only required to optimize assignment synthesis. If you disable assignment synthesis (e.g. using `--disable-assign` option), instrumenting tests with `F1X_RUN` is not needed.

By default, f1x compiles the project using gcc/g++. The compilers can be redefined through `F1X_PROJECT_CC` and `F1X_PROJECT_CXX` environment variables.

### Side effects ###

The f1x tool accepts user options, executes the repair algorithm, and terminates with the following exit codes:

- `0` if a patch is found
- `122` if negative tests are provided but no patch is found
- `123` if no negative tests are provided
- an arbitrary non-zero code in case of errors

Apart from that, f1x produces the following side effects:

- prints log messages on the standard error output
- saves generated patch(es) in the current directory (or the path specified by `--output`)
- saves intermediate data in a temporary directory (the path can be found in log messages)
- transforms/builds/tests the provided project

f1x operates directly on the provided source tree.
Typically, it is safe to execute f1x consequently on the same copy of the project (without `make clean`), however idempotence cannot be guaranteed.
After a successful termination of f1x, the original source files are restored.
If f1x does not terminates successfully (e.g. by receiving `SIGKILL`), the source tree is likely to be corrupted.

### Command-line interface ###

The following arguments are mandatory (and sufficient for most cases):

- project root directory;
- suspicious source files (`--files` option);
- test-suite (`--tests` option);
- test execution timeout (`--test-timeout` option);
- test driver (`--driver` option).

f1x accepts the following arguments:

- `PATH` - the project root directory of your buggy program (positional argument).
- `-f [ --files ] RELPATH...` - the list of suspicious files (that may contain a bug). The paths should be relative to the project root directory. f1x allows to restrict the search space to certain parts of the source code files. For the arguments `--files main.c:20 lib.c:5-45`, the candidate locations will be restricted to the line 20 of `main.c` and from the line 5 to the line 45 (inclusive) of `lib.c`.
- `-t [ --tests ] ID...` - the list of unique test identifiers.
- `-T [ --test-timeout ] MS` - the test execution timeout in milliseconds.
- `-d [ --driver ] PATH` - the path to the test driver. The test driver is executed from the project root directory.
- `-b [ --build ] CMD` - the build command. If omitted, `make -e` is used. The build command is executed from the project root directory.
- `-o [ --output ] PATH` - the path to the output patch (or directory when used with `--all`). If omitted, the patch is generated in the current directory with the name `<SRC>-<TIME>.patch` (or in the directory `<SRC>-<TIME>` when used with `--all`)
- `-a [ --all ]` - enables exploration of the whole search space (generate all plausible patches).
- `-c [ --cost ] FUNCTION` - the cost function used to prioritize patches. If omitted, `syntax-diff` is used.
- `-v [ --verbose ]` - enables extended output for troubleshooting.
- `-h [ --help ]` - prints help message and exits.
- `--version` - prints version and exits.

Run `f1x --help` to view the list of advanced options.

## Related publications ##

**Angelix: Scalable Multiline Program Patch Synthesis via Symbolic Analysis.** [\[pdf\]](http://www.comp.nus.edu.sg/~abhik/pdf/ICSE16-angelix.pdf)  
S. Mechtaev, J. Yi, A. Roychoudhury.  
International Conference on Software Engineering (ICSE) 2016.  

**DirectFix: Looking for Simple Program Repairs.**  [\[pdf\]](https://www.comp.nus.edu.sg/~abhik/pdf/ICSE15-directfix.pdf)  
S. Mechtaev, J. Yi, A. Roychoudhury.  
International Conference on Software Engineering (ICSE) 2015.  

**SemFix: Program Repair via Semantic Analysis.** [\[pdf\]](https://www.comp.nus.edu.sg/~abhik/pdf/ICSE13-SEMFIX.pdf)  
H.D.T. Nguyen, D. Qi, A. Roychoudhury, S. Chandra.  
International Conference on Software Engineering (ICSE) 2013.  
