# Manual #

f1x [ɛf-wʌn-ɛks] is a test-driven patch generation engine for C/C++ programs. It automatically finds and fixes software bugs by analyzing behaviour of passing and failing tests. f1x aims to be efficient, predictable and easy-to-use.

## Characteristics ##

f1x is primarily designed to repair C programs (tested on real-world projects such as PHP, Python, etc.), but it also provides initial support for C++ (tested on small programs). f1x currently works on Linux-based systems (tested on Ubuntu 14.04 and Ubuntu 16.04).

### Search space ###

Search space is the set of syntactical changes that can be generated by a program repair system. The search space of f1x is defined by the following transformation schemas:

1. `expression`: modifying side-effect free expressions (conditions, RHS of assignments, return arguments);
2. `refinement`: appending `|| expr` and `&& expr` to conditions;
3. `assignment`: inserting assignment statements;
4. `guard`: inserting if-guards for break, continue, function calls;
5. `initialization`: inserting memory initialization;
6. `function`: replace a function call with another similar function call.

f1x expression synthesizer is bit-precise; it supports all builtin (C99) integer types and pointers.

### Test-equivalence analyses ###

f1x performs search by applying and testing candidate patches.
Since the search space of f1x includes a huge number of program changes, it is inefficient to test each change individually.
In order to address this, f1x implements several test-equivalence analyses that help to avoid redundant test executions:

1. `vteq`: value-based test-equivalence analysis (for side-effect free program expressions).
2. `dteq`: dependency-based test-equivalence analysis (for assignment synthesis).

### Prioritization ###

Search space prioritization can be thought of as a function that assigns lower cost to better patches. It is straightforward to implement prioritization strategies in f1x, since the search space is represented explicitly and applying prioritization is simply sorting an array. f1x currently supports the following prioritization strategies:

1. `syntax-diff`: minimize syntactic change (patches that are syntactically closer to the original program are assigned lower cost). The motivation behind this prioritization is that small changes are easier to understand and they are less likely to break existing functionality.

## Usage ##

**Warning!** f1x executes arbitrary modifications of your source code which may lead to undesirable side effects. Therefore, it is recommended to run f1x in an isolated environment. Apply f1x to a copy of your application, since it can corrupt the source code.
    
In order to repair a program, f1x requires a special build configuration and an interface to the testing framework.

### Build system ###

It order to let f1x transform and compile your application, you need to substitute C compiler in your build system with the `f1x-cc` tool. For instance, autotools-based projects require

- configuring using f1x compiler wrapper (e.g. `CC=f1x-cc ./configure`)
- removing binaries before executing f1x (e.g. `make clean`)
- ensuring that the build command uses the compiler from the `CC` environment variable (e.g. use `make` with the `-e` option)

### Testing framework ###

f1x needs to be able to execute an arbitrary test to identify if this test passes or fails. To abstract over testing frameworks, f1x uses the following entities:

- A set of unique test identifiers (e.g. "test1", "test2", ...).
- A test driver executable that accepts a test identifier as the only argument, runs the corresponding test, and terminates with zero exit code if and only if the test passes.

When executing tests, f1x appends a path to its runtime library (libf1xrt.so) to the `LD_LIBRARY_PATH` environment variable. Therefore, the testing framework should not overwrite this variable.

In order to perfrom `dteq` analysis, f1x uses dynamic program instrumentation. To enable this, the testing framework has to execute the application binary using the command stored in `F1X_RUN` environment variable, if it is defined. For Bash test scripts, this can be achieved by simply placing `$F1X_RUN` in front of the program execution command:

    assert-equal () {
        diff -q <($F1X_RUN $1) <(echo -ne "$2") > /dev/null
    }

    case "$1" in
        test1)
            assert-equal "./program 1 2" '1\n'
            ;;
    esac

Note that `F1X_RUN` is only required to optimize assignment synthesis. If you disable assignment synthesis (e.g. using `--disable-assign` option), instrumenting tests with `F1X_RUN` is not needed.

### Command-line interface ###

The f1x command-line tool accepts user options, executes the repair algorithm and saves the generated patches in unidiff format. f1x prints log messages on the standard error output and terminates with the following exit codes:

- `0` if a patch is found
- `122` is no patch is found
- a non-zero code in case of errors

The following arguments are mandatory (and sufficient for most cases):

- The source directory.
- The suspicious source files (`--files` option).
- The test-suite (`--tests` option).
- The test execution timeout (`--test-timeout` option).
- The test driver (`--driver` option).

f1x accepts the following arguments:

- `PATH` - the source directory of your buggy program (positional argument).
- `-f [ --files ] RELPATH...` - the list of suspicious files. The paths should be relative to the root of the source directory. f1x allows to restrict the search space to certain parts of the source code files. For the arguments `--files main.c:20 lib.c:5-45`, the candidate locations will be restricted to the line 20 of `main.c` and from the line 5 to the line 45 (inclusive) of `lib.c`.
- `-t [ --tests ] ID...` - the list of unique test identifiers.
- `-T [ --test-timeout ] MS` - the test execution timeout in milliseconds.
- `-d [ --driver ] PATH` - the path to the test driver. The test driver is executed from the root of the source directory.
- `-b [ --build ] CMD` - the build command. If omitted, `make -e` is used. The build command is executed from the root of the source directory.
- `-o [ --output ] PATH` - the path to the output patch (or directory when used with `--all`). If omitted, the patch is generated in the current directory with the name `<SRC>-<TIME>.patch` (or in the directory `<SRC>-<TIME>` when used with `--all`)
- `-a [ --all ]` - enables exploration of the whole search space (generate all plausible patches).
- `-c [ --cost ] FUNCTION` - the cost function used to prioritize patches. If omitted, `syntax-diff` is used.
- `-v [ --verbose ]` - enables extended output for troubleshooting.
- `-h [ --help ]` - prints help message and exits.
- `--version` - prints version and exits.

## Related publications ##

**Angelix: Scalable Multiline Program Patch Synthesis via Symbolic Analysis.** [\[pdf\]](http://www.comp.nus.edu.sg/~abhik/pdf/ICSE16-angelix.pdf)  
S. Mechtaev, J. Yi, A. Roychoudhury.  
International Conference on Software Engineering (ICSE) 2016.  

**DirectFix: Looking for Simple Program Repairs.**  [\[pdf\]](https://www.comp.nus.edu.sg/~abhik/pdf/ICSE15-directfix.pdf)  
S. Mechtaev, J. Yi, A. Roychoudhury.  
International Conference on Software Engineering (ICSE) 2015.  

**SemFix: Program Repair via Semantic Analysis.** [\[pdf\]](https://www.comp.nus.edu.sg/~abhik/pdf/ICSE13-SEMFIX.pdf)  
H.D.T. Nguyen, D. Qi, A. Roychoudhury, S. Chandra.  
International Conference on Software Engineering (ICSE) 2013.  
