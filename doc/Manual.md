# Manual #

f1x [ɛf-wʌn-ɛks] is a test-driven patch generation engine for C/C++ programs. It automatically finds and fixes software bugs by analyzing behaviour of passing and failing tests. f1x aims to be efficient, predictable and easy-to-use.

## Characteristics ##

f1x relies on Clang to perform source code analysis and transformation. f1x is primarily designed to repair C programs (tested on real-world projects such as PHP, Python, etc.), but it also provides initial support for C++ (tested on small programs). f1x currently works on Linux-based systems (tested on Ubuntu 14.04 and Ubuntu 16.04).

### Search space ###

Search space is the set of syntactical changes that can be generated by a program repair system. The search space of f1x is defined by the following transformation schemas:

1. modifying side-effect free expressions (conditions, RHS of assignments, return arguments);
2. appending `|| expr` to conditions with side effects;
3. appending `&& expr` to conditions with side effects;
4. inserting if-guards for break, continue, function calls;
5. inserting memory initialization;

f1x expression synthesizer is bit-precise; it supports all builtin (C99) integer types and pointers.

### Prioritization ###

Search space prioritization can be thought of as a score function that assigns correctness probability to candidate patches. It is straightforward to implement prioritization strategies in f1x, since the search space is represented explicitly and prioritization is simply an array sorting function.

f1x currently supports only the most trivial prioritization strategy: patches that are syntactically closer to the original program are assigned higher correctness probability. f1x guarantees to generate the syntactically minimal patch (the global minimum) in the search space. The motivation behind this prioritization is that small changes are easier to understand and they are less likely to break existing functionality.

Future versions of f1x will include more intelligent prioritization strategies.

## Usage ##

**Warning!** f1x executes arbitrary modifications of your source code which may lead to undesirable side effects. Therefore, it is recommended to run f1x in an isolated environment. Apply f1x to a copy of your application, since it can corrupt the source code.
    
In order to repair a program, f1x requires a special build configuration and an interface to the testing framework.

### Build system ###

It order to let f1x transform and compile your application, you need to substitute C compiler in your build system with the `f1x-cc` tool. For instance, autotools-based projects require

- configuring using f1x compiler wrapper (e.g. `CC=f1x-cc ./configure`)
- removing binaries before executing f1x (e.g. `make clean`)
- ensuring that the build command passed to f1x uses compiler from the `CC` environment variable (e.g. use `make` with the `-e` option)

### Testing framework ###

f1x needs to be able to execute an arbitrary test and to identify if this test passes or fails. To abstract over testing frameworks, f1x uses the following entities:

- A set of unique test identifiers (e.g. "test1", "test2", ...)
- A test driver executable that accepts a test identifier as the only argument, runs the corresponding test, and terminates with zero exit code if and only if the test passes.

Note that when executing tests f1x appends a path to its runtime library (libf1xrt.so) to the `LD_LIBRARY_PATH` environment variable. Therefore, the testing framework should not overwrite this variable.

### Command-line interface ###

f1x command-line tool accepts user options, executes the repair algorithm and saves the generated patches into patch files in unidiff format. f1x prints log messages on the standard error output and terminates with zero exit code if and only if it finds a patch.

f1x accepts the following arguments:

#### PATH ####

The source directory of your buggy program (positional argument).

#### -f [ --files ] RELPATH... ####

The list of buggy files. The paths should be relative to the root of the source directory.

f1x allows to restrict the search space to certain parts of the source code files. In the following example, the candidate locations will be restricted to the line 20 of `main.c` and from the line 5 to the line 45 (inclusive) of `lib.c`:

    --files main.c:20 lib.c:5-45

#### -t [ --tests ] ID... ####

The list of unique test identifiers.

#### -T [ --test-timeout ] MS ####

The test execution timeout in milliseconds.

#### -d [ --driver ] PATH ####

The path to the test driver. The test driver is executed from the root of the source directory.

#### -b [ --build ] CMD ####

The build command. If omitted, `make -e` is used. The build command is executed from the root of the source directory.

#### -o [ --output ] PATH ####

The path to the output patch (or directory when used with `--all`). If omitted, the patch is generated in the current directory with the name `<SRC>-<TIME>.patch` (or in the directory `<SRC>-<TIME>` when used with `--all`)

#### -a [ --all ] ####

Enables exploration of whole search space.

#### -v [ --verbose ] ####

Enables extended output for troubleshooting.

#### -h [ --help ] ####

Prints help message and exits.

#### --version ####

Prints version and exits.

## Related publications ##

**Angelix: Scalable Multiline Program Patch Synthesis via Symbolic Analysis.** [\[pdf\]](http://www.comp.nus.edu.sg/~abhik/pdf/ICSE16-angelix.pdf)  
S. Mechtaev, J. Yi, A. Roychoudhury.  
International Conference on Software Engineering (ICSE) 2016.  

**DirectFix: Looking for Simple Program Repairs.**  [\[pdf\]](https://www.comp.nus.edu.sg/~abhik/pdf/ICSE15-directfix.pdf)  
S. Mechtaev, J. Yi, A. Roychoudhury.  
International Conference on Software Engineering (ICSE) 2015.  

**SemFix: Program Repair via Semantic Analysis.** [\[pdf\]](https://www.comp.nus.edu.sg/~abhik/pdf/ICSE13-SEMFIX.pdf)  
H.D.T. Nguyen, D. Qi, A. Roychoudhury, S. Chandra.  
International Conference on Software Engineering (ICSE) 2013.  
